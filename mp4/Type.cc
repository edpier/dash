#include "Type.h"

#include <cstring>

#include "MP4Exception.h"

/******************************************************************************//**
*
**********************************************************************************/
Type::Type() {
    
} // end of constructor

/******************************************************************************//**
*
**********************************************************************************/
Type::Type(const std::string& type) {
    
    if(type.length() != 4) {
        throw MP4Exception("Invalid type code "+type);
    }
    
    this->string = type;
    char* bytes = (char*)(&code);
    bytes[0] = string[3];
    bytes[1] = string[2];
    bytes[2] = string[1];
    bytes[3] = string[0];
    
    //std::cout<<"created "<<|"<<this->string<<"| code="<<code<<std::endl;
    
    
} // end of constructor
      
/******************************************************************************//**
*
**********************************************************************************/  
Type::Type(const Type& type) {
    
    *this = type;
    
} // end of copy constructor
    
/******************************************************************************//**
*
**********************************************************************************/
uint32_t Type::getCode() const { return code; }
    
/******************************************************************************//**
*
**********************************************************************************/
const std::string& Type::getString() const { return string; }
    
/******************************************************************************//**
*
**********************************************************************************/
int Type::getSize() { return 4; }
    
/******************************************************************************//**
*
**********************************************************************************/
void Type::read(ByteSource& source) {
    
    code = source.readUint32();
    char* tmp = (char*)(&code);
    
    char bytes[5];
    bytes[4] = '\0';
    
    bytes[0] = tmp[3];
    bytes[1] = tmp[2];
    bytes[2] = tmp[1];
    bytes[3] = tmp[0];
    
    string = bytes;
    
} // end of read method
       
/******************************************************************************//**
*
**********************************************************************************/
void Type::write(ByteSink& sink) const {
    
    sink.writeUint32(code);
    
} // end of write method
       
/******************************************************************************//**
*
**********************************************************************************/
const Type& Type::operator=(const Type& type) {
    
    this->string = type.string;
    this->code   = type.code;
    
    return *this;
    
} // end of assignment operator
       
/******************************************************************************//**
*
**********************************************************************************/
bool Type::operator==(const std::string& string) const {
    
    return this->string == string;
    
} // end of equals string operator

/******************************************************************************//**
*
**********************************************************************************/
bool Type::operator!=(const std::string& string) const {
    
    return !(*this == string);
    
} // end of not equals string method

/******************************************************************************//**
*
**********************************************************************************/
std::ostream& operator<<(std::ostream& out, const Type& type) {
    
    std::cout << type.string;
    
    return out;
    
} // end of print operator
